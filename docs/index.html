<!doctype html>
<html class="default no-js">
<head>
	<meta charset="utf-8">
	<meta http-equiv="X-UA-Compatible" content="IE=edge">
	<title>edge-lexer</title>
	<meta name="description" content="">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<link rel="stylesheet" href="assets/css/main.css">
</head>
<body>
<header>
	<div class="tsd-page-toolbar">
		<div class="container">
			<div class="table-wrap">
				<div class="table-cell" id="tsd-search" data-index="assets/js/search.js" data-base=".">
					<div class="field">
						<label for="tsd-search-field" class="tsd-widget search no-caption">Search</label>
						<input id="tsd-search-field" type="text" />
					</div>
					<ul class="results">
						<li class="state loading">Preparing search index...</li>
						<li class="state failure">The search index is not available</li>
					</ul>
					<a href="index.html" class="title">edge-lexer</a>
				</div>
				<div class="table-cell" id="tsd-widgets">
					<div id="tsd-filter">
						<a href="#" class="tsd-widget options no-caption" data-toggle="options">Options</a>
						<div class="tsd-filter-group">
							<div class="tsd-select" id="tsd-filter-visibility">
								<span class="tsd-select-label">All</span>
								<ul class="tsd-select-list">
									<li data-value="public">Public</li>
									<li data-value="protected">Public/Protected</li>
									<li data-value="private" class="selected">All</li>
								</ul>
							</div>
							<input type="checkbox" id="tsd-filter-inherited" checked />
							<label class="tsd-widget" for="tsd-filter-inherited">Inherited</label>
							<input type="checkbox" id="tsd-filter-externals" checked />
							<label class="tsd-widget" for="tsd-filter-externals">Externals</label>
							<input type="checkbox" id="tsd-filter-only-exported" />
							<label class="tsd-widget" for="tsd-filter-only-exported">Only exported</label>
						</div>
					</div>
					<a href="#" class="tsd-widget menu no-caption" data-toggle="menu">Menu</a>
				</div>
			</div>
		</div>
	</div>
	<div class="tsd-page-title">
		<div class="container">
			<ul class="tsd-breadcrumb">
				<li>
					<a href="globals.html">Globals</a>
				</li>
			</ul>
			<h1> edge-lexer</h1>
		</div>
	</div>
</header>
<div class="container container-main">
	<div class="row">
		<div class="col-8 col-content">
			<div class="tsd-panel tsd-typography">
				<h1 id="edge-lexer">Edge lexer</h1>
				<p>Edge lexer detects tags from any markup language and converts them into tokens. Later these tokens can be used with a Javascript parser like <code>esprima</code> or <code>babylon</code> to complete a logical template engine ( this is what Edge does ).</p>
				<p>This guide is an outline of the lexer.</p>
				<hr>
				<h2 id="note">Note</h2>
				<p>The code used in examples is only subject to work, when using Edge template engine. The lexer job is to tokenize the whitelisted syntax.</p>
				<p>The real functionality is added by the template engine by using the tokens created from this package </p>
				<hr>
				<h2 id="features">Features</h2>
				<ol>
					<li>Allows multiline expressions.</li>
					<li>Whitespaces and newlines are retained.</li>
					<li>Works with any markup or plain text files.</li>
					<li>Syntax is close to Javascript.</li>
				</ol>
				<h2 id="terms-used">Terms used</h2>
				<p>This guide makes use of the following terms to identify core pieces of the tokenizer.</p>
				<table>
					<thead>
						<tr>
							<th>Term</th>
							<th>Node Type</th>
							<th>Description</th>
						</tr>
					</thead>
					<tbody>
						<tr>
							<td>Tag</td>
							<td>block</td>
							<td>Tags are used to define logical blocks in the template engine. For example <code>if tag</code> or <code>include tag</code>.</td>
						</tr>
						<tr>
							<td>Mustache</td>
							<td>mustache</td>
							<td>Javascript expression wrapped around curly braces. <code>{{ }}</code></td>
						</tr>
						<tr>
							<td>Raw</td>
							<td>raw</td>
							<td>A raw string, which has no meaning for the template engine</td>
						</tr>
						<tr>
							<td>NewLine</td>
							<td>newline</td>
							<td>Newline</td>
						</tr>
					</tbody>
				</table>
				<h2 id="nodes">Nodes</h2>
				<p>Following is the list of Nodes returned by the tokenizer.</p>
				<h4 id="block-node">Block Node</h4>
				<pre><code class="lang-js">{
  <span class="hljs-attr">type</span>: <span class="hljs-string">'block'</span>
  lineno: number,
  <span class="hljs-attr">properties</span>: Prop,
  <span class="hljs-attr">children</span>: []
}
</code></pre>
				<h4 id="raw-node">Raw Node</h4>
				<pre><code class="lang-js">{
  <span class="hljs-attr">type</span>: <span class="hljs-string">'raw'</span>,
  <span class="hljs-attr">lineno</span>: number,
  <span class="hljs-attr">value</span>: string
}
</code></pre>
				<h4 id="mustache-node">Mustache Node</h4>
				<pre><code class="lang-js">{
  <span class="hljs-attr">type</span>: <span class="hljs-string">'mustache'</span>,
  <span class="hljs-attr">lineno</span>: number,
  <span class="hljs-attr">properties</span>: Prop
}
</code></pre>
				<h4 id="newline-node">NewLine Node</h4>
				<pre><code class="lang-js">{
  <span class="hljs-attr">type</span>: <span class="hljs-string">'newline'</span>,
  <span class="hljs-attr">lineno</span>: number
}
</code></pre>
				<p><code>Block Node</code> is the only node, which contains recursive child nodes.</p>
				<table>
					<thead>
						<tr>
							<th>Key</th>
							<th>Value</th>
							<th>Description</th>
						</tr>
					</thead>
					<tbody>
						<tr>
							<td>type</td>
							<td>string</td>
							<td>The type of node determines the behavior of node</td>
						</tr>
						<tr>
							<td>lineno</td>
							<td>number</td>
							<td>The lineno in the source file</td>
						</tr>
						<tr>
							<td>properties</td>
							<td>Prop</td>
							<td>Meta data for the node. See <a href="#properties">Properties</a> to more info.</td>
						</tr>
						<tr>
							<td>value</td>
							<td>string</td>
							<td>If node is a raw node, then value is the string in the source file</td>
						</tr>
						<tr>
							<td>children</td>
							<td>array</td>
							<td>Array of recursive nodes.</td>
						</tr>
					</tbody>
				</table>
				<h2 id="properties">Properties</h2>
				<p>The properties <code>Prop</code> is used to define meta data for a given Node. Nodes like <code>raw</code> and <code>newline</code>, doesn&#39;t need any metadata. </p>
				<h4 id="prop">Prop</h4>
				<pre><code class="lang-js">{
  <span class="hljs-attr">name</span>: string
  jsArg: string,
  <span class="hljs-attr">raw</span>: string
}
</code></pre>
				<table>
					<thead>
						<tr>
							<th>Key</th>
							<th>Description</th>
						</tr>
					</thead>
					<tbody>
						<tr>
							<td>name</td>
							<td>The name is the subtype for a given node. For example: <code>if</code> will be the name of the <code>@if</code> tag.</td>
						</tr>
						<tr>
							<td>jsArg</td>
							<td>The <code>jsArg</code> is the Javascript expression to evaluate</td>
						</tr>
						<tr>
							<td>raw</td>
							<td>The raw representation of a given expression. Used for debugging purposes.</td>
						</tr>
					</tbody>
				</table>
				<h2 id="example">Example</h2>
				<p>Before reading more about the syntax and their output, let&#39;s check the following example.</p>
				<pre><code class="lang-html">@if(username)
  <span class="hljs-tag">&lt;<span class="hljs-name">h2</span>&gt;</span> Hello {{ username }} <span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span>
@endif
</code></pre>
				<p>The output of the above text will be</p>
				<pre><code class="lang-js">[
  {
    <span class="hljs-string">"type"</span>: <span class="hljs-string">"block"</span>,
    <span class="hljs-string">"properties"</span>: {
      <span class="hljs-string">"name"</span>: <span class="hljs-string">"if"</span>,
      <span class="hljs-string">"jsArg"</span>: <span class="hljs-string">"username"</span>,
      <span class="hljs-string">"raw"</span>: <span class="hljs-string">"if(username)"</span>
    },
    <span class="hljs-string">"lineno"</span>: <span class="hljs-number">1</span>,
    <span class="hljs-string">"children"</span>: [
      {
        <span class="hljs-string">"type"</span>: <span class="hljs-string">"newline"</span>,
        <span class="hljs-string">"lineno"</span>: <span class="hljs-number">1</span>
      },
      {
        <span class="hljs-string">"type"</span>: <span class="hljs-string">"raw"</span>,
        <span class="hljs-string">"value"</span>: <span class="hljs-string">"&lt;h2&gt; Hello "</span>,
        <span class="hljs-string">"lineno"</span>: <span class="hljs-number">2</span>
      },
      {
        <span class="hljs-string">"type"</span>: <span class="hljs-string">"mustache"</span>,
        <span class="hljs-string">"lineno"</span>: <span class="hljs-number">2</span>,
        <span class="hljs-string">"properties"</span>: {
          <span class="hljs-string">"name"</span>: <span class="hljs-string">"mustache"</span>,
          <span class="hljs-string">"jsArg"</span>: <span class="hljs-string">" username "</span>,
          <span class="hljs-string">"raw"</span>: <span class="hljs-string">"{{ username }}"</span>
        }
      },
      {
        <span class="hljs-string">"type"</span>: <span class="hljs-string">"raw"</span>,
        <span class="hljs-string">"value"</span>: <span class="hljs-string">" &lt;/h2&gt;"</span>,
        <span class="hljs-string">"lineno"</span>: <span class="hljs-number">2</span>
      },
      {
        <span class="hljs-string">"type"</span>: <span class="hljs-string">"newline"</span>,
        <span class="hljs-string">"lineno"</span>: <span class="hljs-number">2</span>
      }
    ]
  },
  {
    <span class="hljs-string">"type"</span>: <span class="hljs-string">"newline"</span>,
    <span class="hljs-string">"lineno"</span>: <span class="hljs-number">3</span>
  }
]
</code></pre>
				<h2 id="supported-syntax">Supported Syntax</h2>
				<p>To make Edge an enjoyable template engine, we have kept the syntax very close the original Javascript syntax.</p>
				<p>The following expressions are allowed.</p>
				<h2 id="tags-block-">Tags (block)</h2>
				<ol>
					<li>Every block level tag starts with <code>@</code> symbol followed by the tagName.</li>
					<li>It is important to close a block level using <code>@end&lt;tagName&gt;</code></li>
					<li><code>@</code> and <code>tagName</code> cannot have spaces between them.</li>
				</ol>
				<p><strong>VALID</strong></p>
				<pre><code><span class="hljs-variable">@if</span>(username)
<span class="hljs-variable">@endif</span>
</code></pre><p><strong>VALID</strong></p>
				<pre><code><span class="hljs-variable">@if</span>(
  username
)
<span class="hljs-variable">@endif</span>
</code></pre><p><strong>VALID</strong></p>
				<pre><code>@if(
  (
    <span class="hljs-number">2</span> + <span class="hljs-number">2</span>
  )
  ===
  <span class="hljs-number">4</span>
)
</code></pre><p><strong>VALID</strong></p>
				<pre><code>@<span class="hljs-keyword">if</span>
<span class="hljs-comment">(
 username
)</span>
</code></pre><p><strong>INVALID</strong></p>
				<p>The opening of the tag must be in it&#39;s own line and so do the closing one</p>
				<pre><code><span class="hljs-variable">@if</span>(username) Hello <span class="hljs-variable">@endif</span>
</code></pre><p><strong>INVALID</strong></p>
				<pre><code><span class="hljs-variable">@if</span>(
  username
) &lt;p&gt; Hello &lt;/p&gt;
<span class="hljs-variable">@endif</span>
</code></pre><h2 id="tags-inline-">Tags (inline)</h2>
				<p>The inline tags doesn&#39;t contain any childs and hence requires no <code>@end</code> statement.</p>
				<p><strong>VALID</strong></p>
				<pre><code><span class="hljs-meta">@include(<span class="hljs-meta-string">'header'</span>)</span>
</code></pre><p><strong>VALID</strong></p>
				<pre><code><span class="hljs-meta">@include(
  <span class="hljs-meta-string">'header'</span>
)</span>
</code></pre><p><strong>VALID</strong></p>
				<pre><code><span class="hljs-meta">@include</span>
(
  <span class="hljs-string">'header'</span>
)
</code></pre><h2 id="tags-block-self-closed-">Tags (block-self closed)</h2>
				<p>At times block level tags can work fine without any body inside them. To keep the syntax concise, you can <strong>self-close</strong> a block level tag.</p>
				<p><strong>NORMAL</strong></p>
				<pre><code><span class="hljs-variable">@component</span>(<span class="hljs-string">'title'</span>)
  &lt;h1&gt; Hello world &lt;/h1&gt;
<span class="hljs-variable">@endcomponent</span>
</code></pre><p><strong>SELF CLOSED</strong></p>
				<pre><code>@!<span class="hljs-keyword">component</span>('<span class="hljs-keyword">title</span>', title = <span class="hljs-string">'&lt;h1&gt; Hello world &lt;/h1&gt;'</span>)
</code></pre><h2 id="mustache">Mustache</h2>
				<p>The mustache braces <code>{{</code> are used to define inline Javascript expressions. The lexer allows</p>
				<ol>
					<li>Multiline expressions</li>
					<li>A valid Javascript expression, that yields to a value.</li>
					<li>The return value is HTML escaped by Edge, so make sure to use <code>{{{ &#39;&lt;p&gt;&#39; Hello world &lt;/p&gt; }}}</code> for rendering HTML nodes.</li>
				</ol>
				<p><strong>VALID</strong></p>
				<pre><code>{{ username }}
</code></pre><p><strong>VALID</strong></p>
				<pre><code>{{
 username
}}
</code></pre><p><strong>VALID</strong></p>
				<pre><code>Your friends are {{
  users.map(<span class="hljs-function"><span class="hljs-params">(user)</span> =&gt;</span> {
    <span class="hljs-keyword">return</span> user.username
  }).join(<span class="hljs-string">','</span>)
}}
</code></pre><p><strong>VALID</strong></p>
				<pre><code>{{{ <span class="hljs-string">'&lt;p&gt;'</span> Hello world &lt;/p&gt; }}}
</code></pre><p><strong>INVALID</strong></p>
				<p>The starting curly brace, must be in one line.</p>
				<pre><code>{
{
  username
}
}
</code></pre><h2 id="escaping">Escaping</h2>
				<p>The backslash <code>\</code> is used for escaping mustache braces and tags.</p>
				<blockquote>
					<p>There is no need to escape the <code>@end</code> statements, since they are tightly mapped with the start statements. So if a start statement doesn&#39;t exists, the end statement will be considered as a raw node.</p>
				</blockquote>
				<pre><code>\<span class="hljs-variable">@if</span>(username)
<span class="hljs-variable">@endif</span>
</code></pre><p>yields</p>
				<pre><code class="lang-json">[
  {
    <span class="hljs-attr">"type"</span>: <span class="hljs-string">"raw"</span>,
    <span class="hljs-attr">"value"</span>: <span class="hljs-string">"@if(username)"</span>,
    <span class="hljs-attr">"lineno"</span>: <span class="hljs-number">1</span>
  },
  {
    <span class="hljs-attr">"type"</span>: <span class="hljs-string">"newline"</span>,
    <span class="hljs-attr">"lineno"</span>: <span class="hljs-number">1</span>
  },
  {
    <span class="hljs-attr">"type"</span>: <span class="hljs-string">"raw"</span>,
    <span class="hljs-attr">"value"</span>: <span class="hljs-string">"@endif"</span>,
    <span class="hljs-attr">"lineno"</span>: <span class="hljs-number">2</span>
  },
  {
    <span class="hljs-attr">"type"</span>: <span class="hljs-string">"newline"</span>,
    <span class="hljs-attr">"lineno"</span>: <span class="hljs-number">2</span>
  }
]
</code></pre>
				<p>In the same fashion, the mustache braces can be escaped using <code>\</code>.</p>
				<pre><code>Hello <span class="hljs-tag">\<span class="hljs-name">{</span><span class="hljs-string">{username}</span></span>}
</code></pre><p>For legacy reasons, the <code>@</code> symbol can also be used for escaping mustache braces.</p>
				<pre><code>Hello @{{username}}
</code></pre>
			</div>
		</div>
		<div class="col-4 col-menu menu-sticky-wrap menu-highlight">
			<nav class="tsd-navigation primary">
				<ul>
					<li class="globals  ">
						<a href="globals.html"><em>Globals</em></a>
					</li>
					<li class=" tsd-kind-external-module">
						<a href="modules/lexer.html">Lexer</a>
					</li>
				</ul>
			</nav>
			<nav class="tsd-navigation secondary menu-sticky">
				<ul class="before-current">
				</ul>
			</nav>
		</div>
	</div>
</div>
<footer class="with-border-bottom">
	<div class="container">
		<h2>Legend</h2>
		<div class="tsd-legend-group">
			<ul class="tsd-legend">
				<li class="tsd-kind-module"><span class="tsd-kind-icon">Module</span></li>
				<li class="tsd-kind-object-literal"><span class="tsd-kind-icon">Object literal</span></li>
				<li class="tsd-kind-variable"><span class="tsd-kind-icon">Variable</span></li>
				<li class="tsd-kind-function"><span class="tsd-kind-icon">Function</span></li>
				<li class="tsd-kind-function tsd-has-type-parameter"><span class="tsd-kind-icon">Function with type parameter</span></li>
				<li class="tsd-kind-index-signature"><span class="tsd-kind-icon">Index signature</span></li>
				<li class="tsd-kind-type-alias"><span class="tsd-kind-icon">Type alias</span></li>
			</ul>
			<ul class="tsd-legend">
				<li class="tsd-kind-enum"><span class="tsd-kind-icon">Enumeration</span></li>
				<li class="tsd-kind-enum-member"><span class="tsd-kind-icon">Enumeration member</span></li>
				<li class="tsd-kind-property tsd-parent-kind-enum"><span class="tsd-kind-icon">Property</span></li>
				<li class="tsd-kind-method tsd-parent-kind-enum"><span class="tsd-kind-icon">Method</span></li>
			</ul>
			<ul class="tsd-legend">
				<li class="tsd-kind-interface"><span class="tsd-kind-icon">Interface</span></li>
				<li class="tsd-kind-interface tsd-has-type-parameter"><span class="tsd-kind-icon">Interface with type parameter</span></li>
				<li class="tsd-kind-constructor tsd-parent-kind-interface"><span class="tsd-kind-icon">Constructor</span></li>
				<li class="tsd-kind-property tsd-parent-kind-interface"><span class="tsd-kind-icon">Property</span></li>
				<li class="tsd-kind-method tsd-parent-kind-interface"><span class="tsd-kind-icon">Method</span></li>
				<li class="tsd-kind-index-signature tsd-parent-kind-interface"><span class="tsd-kind-icon">Index signature</span></li>
			</ul>
			<ul class="tsd-legend">
				<li class="tsd-kind-class"><span class="tsd-kind-icon">Class</span></li>
				<li class="tsd-kind-class tsd-has-type-parameter"><span class="tsd-kind-icon">Class with type parameter</span></li>
				<li class="tsd-kind-constructor tsd-parent-kind-class"><span class="tsd-kind-icon">Constructor</span></li>
				<li class="tsd-kind-property tsd-parent-kind-class"><span class="tsd-kind-icon">Property</span></li>
				<li class="tsd-kind-method tsd-parent-kind-class"><span class="tsd-kind-icon">Method</span></li>
				<li class="tsd-kind-accessor tsd-parent-kind-class"><span class="tsd-kind-icon">Accessor</span></li>
				<li class="tsd-kind-index-signature tsd-parent-kind-class"><span class="tsd-kind-icon">Index signature</span></li>
			</ul>
			<ul class="tsd-legend">
				<li class="tsd-kind-constructor tsd-parent-kind-class tsd-is-inherited"><span class="tsd-kind-icon">Inherited constructor</span></li>
				<li class="tsd-kind-property tsd-parent-kind-class tsd-is-inherited"><span class="tsd-kind-icon">Inherited property</span></li>
				<li class="tsd-kind-method tsd-parent-kind-class tsd-is-inherited"><span class="tsd-kind-icon">Inherited method</span></li>
				<li class="tsd-kind-accessor tsd-parent-kind-class tsd-is-inherited"><span class="tsd-kind-icon">Inherited accessor</span></li>
			</ul>
			<ul class="tsd-legend">
				<li class="tsd-kind-property tsd-parent-kind-class tsd-is-protected"><span class="tsd-kind-icon">Protected property</span></li>
				<li class="tsd-kind-method tsd-parent-kind-class tsd-is-protected"><span class="tsd-kind-icon">Protected method</span></li>
				<li class="tsd-kind-accessor tsd-parent-kind-class tsd-is-protected"><span class="tsd-kind-icon">Protected accessor</span></li>
			</ul>
			<ul class="tsd-legend">
				<li class="tsd-kind-property tsd-parent-kind-class tsd-is-private"><span class="tsd-kind-icon">Private property</span></li>
				<li class="tsd-kind-method tsd-parent-kind-class tsd-is-private"><span class="tsd-kind-icon">Private method</span></li>
				<li class="tsd-kind-accessor tsd-parent-kind-class tsd-is-private"><span class="tsd-kind-icon">Private accessor</span></li>
			</ul>
			<ul class="tsd-legend">
				<li class="tsd-kind-property tsd-parent-kind-class tsd-is-static"><span class="tsd-kind-icon">Static property</span></li>
				<li class="tsd-kind-call-signature tsd-parent-kind-class tsd-is-static"><span class="tsd-kind-icon">Static method</span></li>
			</ul>
		</div>
	</div>
</footer>
<div class="container tsd-generator">
	<p>Generated using <a href="http://typedoc.org/" target="_blank">TypeDoc</a></p>
</div>
<div class="overlay"></div>
<script src="assets/js/main.js"></script>
<script>if (location.protocol == 'file:') document.write('<script src="assets/js/search.js"><' + '/script>');</script>
</body>
</html>